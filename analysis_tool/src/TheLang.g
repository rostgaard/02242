/*
 * ANTRL (http://www.antlr.org/) grammar for the project language. You will
 * probably want to adapt the file to generate parser for your language of
 * choice and use your own data structures (or define tree parser to traverse
 * the tree generated by ANTLR).
 *
 * Note that this has not been throughly tested, so let us know if there are
 * any problems.
 */

grammar TheLang;

options {
  language= Java;  /* Change this to generate parser for some other language. */
  backtrack = true;
  memoize = true;
  output = AST;
  ASTLabelType = CommonTree;
}

tokens {
  AND = '&';
  OR = '|';
  ASSIGN = ':=';
  SEMI = ';';
  GT = '>';
  GE = '>=';
  LT = '<';
  LE = '<=';
  EQ = '=';
  NEQ = '!=';
  PLUS = '+';
  MINUS = '-';
  MUL = '*';
  DIV = '/';
  NOT = '!';
  LPAREN = '(';
  RPAREN = ')';
  LBRACE = '{';
  RBRACE = '}';
  LBRACKET = '[';
  RBRACKET = ']';
  COLON = ':';
  IF = 'if';
  THEN = 'then';
  ELSE = 'else';
  FI = 'fi';
  WHILE = 'while';
  DO = 'do';
  OD = 'od';
  SKIP = 'skip';
  WRITE = 'write';
  READ = 'read';
  PROGRAM = 'program';
  END = 'end';
  TRUE = 'true';
  FALSE = 'false';
  INT = 'int';
  LOW = 'low';
  HIGH = 'high';
}


@header {
  import java.util.ArrayList;
  import syntaxtree.condition.*;
  import syntaxtree.declaration.*;
  import syntaxtree.expression.*;
  import syntaxtree.statement.*;
}


aexpr : aexpr1 (PLUS aexpr1 | MINUS aexpr1)* ;

aexpr1 : aexpr2 (MUL aexpr2 | DIV aexpr2)* ;

aexpr2 returns [Expression value]
    : MINUS expr = aexpr3 {$value = new NegationExpression(expr);}
    | expr = aexpr3 {$value = expr);}
    ;

aexpr3 returns [Expression value] 
    : id = IDENTIFIER {$value = new Variable(Type.INT, $id);}
    | id = IDENTIFIER LBRACKET idx = aexpr RBRACKET {$value = new ArrayExpression(new Variable(Type.ARRAY, $id), $idx);}	
    | cons = INTEGER {$value = new Constant($cons);}
    | LPAREN expr = aexpr RPAREN {$value = new ParanthesesExpression($expr);}
    ;

bexpr : bexpr1 (OR bexpr1)*
      ;

bexpr1 : bexpr2 (AND bexpr2)*
       ;

bexpr2 returns [Condition value] 
    : expr1 = aexpr oa = opr expr = aexpr {$value = new ConditionExpressionOperation($expr1, $expr2, $oa);}
    | NOT cond = bexpr {$value = new NegationCondition($cond);} 
    | TRUE {$value = new ConditionTrue();}
    | FALSE {$value = new ConditionFalse();}
    | LPAREN cond = bexpr RPAREN {$value = new ConditionParanteses($cond);} 
    ;

opr returns [OperationRelation value]
    : GT {$value = OperationRelation.GREATERTHAN}
    | GE {$value = OperationRelation.GREATEREQUALTHAN}
    | LT {$value = OperationRelation.LESSTHAN}
    | LE {$value = OperationRelation.LESSEQUALTHAN}
    | EQ {$value = OperationRelation.EQUAL}
    | NEQ {$value = OperationRelation.NOTEQUAL}
    ;

decl returns [Decleration value]
    : lvl = level? INT id = IDENTIFIER val = INTEGER SEMI {$value = new Int($lvl, new Variable($id), $val);} 
    | lvl = level? INT id = IDENTIFIER (LBRACKET size = INTEGER RBRACKET)? SEMI {$value = new Array(lvl, new Variable(id), val);} 
    ;


level returns[Level value] 
    : LOW {$value = Level.LOW}  
    | HIGH {$value = Level.HIGH}
    ;
    
stmt returns [Statement value]
     : statement = assignStmt
     | statement = skipStmt
     | statement = readStmt
     | statement = writeStmt
     | statement = ifStmt
     | statement = whileStmt
     {{$value = $statement}
     ;

assignStmt returns [Statement value]
    : id = IDENTIFIER ASSIGN exp = aexpr SEMI
      {$value = new Assignment($id, $exp);}	   
    | id = IDENTIFIER (LBRACKET idx = aexpr RBRACKET)? ASSIGN exp = aexpr SEMI
      {$value = new AssignmentArray($id, $idx, $exp);}
    ;

skipStmt returns [Statement value]
    : SKIP SEMI
      {$value = new Skip();} 
    ;

readStmt returns [Statement value]
    : READ id = IDENTIFIER SEMI 
      {$value = new Read($id);}
    | READ id = IDENTIFIER LBRACKET index = aexpr RBRACKET SEMI 
      {$value = new ReadArray($id, $index);}
    ;
    
writeStmt returns [Statement value] 
    : WRITE expr = aexpr SEMI
      {$value = new Write($expr);} 
    ;

ifStmt returns [Statement value]
    @init
    {
    	$trueList = new ArrayList<Statement>();
    	$falseList = new ArrayList<Statment>();
    }
    : IF exp = bexpr THEN (trueStmt = stmt {$trueList.add($trueStmt);})+ ELSE (falseStmt = stmt {$falseList.add($falseStmt);})+ FI 
      {$value = new If($exp, $trueList, $falseList);}  
    ;

whileStmt returns [Statement value]
    @init	
    {
    	$stmtList = new ArrayList<Statement>();
    }
    : WHILE exp = bexpr DO (statement = stmt {$stmtList.add($statement);})+ OD 
      {$value = new While($exp, $stmtList);} 
    ;

program returns [Program value]
    @init
    {
    	$declList = new ArrayList<Declaration>();
    	$stmtList = new ArrayList<Statement>();
    }
    : PROGRAM (declaration = decl {$declList.add($decleration);})* (statement = stmt {$stmtList.Add($statement);})+ END 
      {$value = new Program($DeclList, $StmtList);} 
    ;

COMMENT : '(*' (options {greedy=false;} : .)* '*)' {$channel=HIDDEN;};

INTEGER : ('0' | '1'..'9' '0'..'9'*);

IDENTIFIER : LETTER (LETTER|'0'..'9')* ;

fragment
LETTER : 'A'..'Z'
       | 'a'..'z'
       | '_'
       ;

WS : (' '|'\r'|'\t'|'\u000C'|'\n') {skip();};